<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Expressionismus</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a0804;
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    font-family: serif;
  }
  .frame {
    border: 8px solid #2a1f0f;
    box-shadow: 
      0 0 0 2px #8b6914,
      0 0 0 4px #2a1f0f,
      4px 4px 30px rgba(0,0,0,0.9),
      -4px -4px 30px rgba(0,0,0,0.7);
    position: relative;
    width: 600px;
    height: 480px;
    overflow: hidden;
  }
  canvas {
    display: block;
    width: 600px;
    height: 480px;
  }
</style>
</head>
<body>
<div class="frame">
  <canvas id="c" width="600" height="480"></canvas>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = 600, H = 480;

let t = 0;

// Expressionist color palette
const colors = [
  '#c8310a', // fiery red
  '#e8780a', // orange
  '#1a3a6e', // deep prussian blue
  '#f0c030', // acid yellow
  '#2d0a0a', // near black red
  '#7a1a1a', // dark crimson
  '#d4a020', // ochre
  '#0a1a3a', // midnight blue
  '#8b3a0a', // burnt sienna
  '#1a0a2a', // dark violet
  '#e8320a', // vermillion
  '#c8a000', // raw sienna
];

function noise(x, y, z) {
  // Simple pseudo-noise
  return Math.sin(x * 1.3 + z) * Math.cos(y * 0.9 - z * 0.7) * 
         Math.sin(x * 0.7 + y * 1.1 + z * 0.5);
}

function drawFigure(x, y, scale, phase) {
  // Distorted expressionist human silhouette
  ctx.save();
  ctx.translate(x, y);
  ctx.scale(scale, scale + Math.sin(phase) * 0.08);
  
  const distort = Math.sin(phase * 0.7) * 12;
  const stretch = 1 + Math.sin(phase * 0.4) * 0.15;
  
  // Body
  ctx.beginPath();
  ctx.moveTo(distort, -80 * stretch);
  ctx.bezierCurveTo(
    30 + distort, -60 * stretch,
    40, -20,
    20 + Math.sin(phase) * 8, 0
  );
  ctx.bezierCurveTo(
    35, 30,
    25, 60,
    10 + distort * 0.5, 90
  );
  ctx.bezierCurveTo(
    -10, 100,
    -30, 90,
    -20 - distort * 0.5, 90
  );
  ctx.bezierCurveTo(
    -35, 60,
    -40, 30,
    -25 - Math.sin(phase) * 8, 0
  );
  ctx.bezierCurveTo(
    -45, -20,
    -35 - distort, -60 * stretch,
    -distort, -80 * stretch
  );
  ctx.closePath();
  
  const grd = ctx.createLinearGradient(-40, -80, 40, 90);
  grd.addColorStop(0, colors[Math.floor((phase * 0.3) % colors.length)]);
  grd.addColorStop(1, colors[Math.floor((phase * 0.3 + 3) % colors.length)]);
  ctx.fillStyle = grd;
  ctx.fill();
  
  // Head
  ctx.beginPath();
  ctx.ellipse(
    distort * 0.5, 
    -95 * stretch, 
    22 + Math.sin(phase * 1.1) * 4, 
    28 + Math.cos(phase * 0.8) * 5, 
    Math.sin(phase * 0.6) * 0.4, 
    0, Math.PI * 2
  );
  ctx.fillStyle = colors[Math.floor((phase * 0.5 + 1) % colors.length)];
  ctx.fill();
  
  ctx.restore();
}

function drawSky(t) {
  // Turbulent expressionist sky
  for (let y = 0; y < H * 0.6; y += 4) {
    for (let x = 0; x < W; x += 4) {
      const n = noise(x * 0.015, y * 0.015, t * 0.008) +
                noise(x * 0.04, y * 0.03, t * 0.012) * 0.5;
      
      const idx = Math.abs(Math.floor(n * 4 + 5)) % colors.length;
      const alpha = 0.3 + Math.abs(n) * 0.5;
      
      ctx.fillStyle = colors[idx];
      ctx.globalAlpha = alpha * 0.7;
      ctx.fillRect(x, y, 5, 5);
    }
  }
}

function drawGround(t) {
  // Ground with wild strokes
  ctx.globalAlpha = 1;
  for (let i = 0; i < 30; i++) {
    const x1 = (i / 30) * W + Math.sin(t * 0.02 + i) * 20;
    const y1 = H * 0.55 + Math.sin(t * 0.015 + i * 0.5) * 25 + i * 1.5;
    
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.bezierCurveTo(
      x1 + 30, y1 + Math.sin(t * 0.03 + i) * 15,
      x1 + 60, y1 + Math.cos(t * 0.025 + i) * 10,
      x1 + W / 15, y1 + 10
    );
    
    const strokeColor = i % 2 === 0 ? colors[2] : colors[11];
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = 6 + Math.sin(t * 0.04 + i) * 3;
    ctx.globalAlpha = 0.4 + Math.sin(t * 0.02 + i) * 0.2;
    ctx.stroke();
  }
}

function drawLines(t) {
  // Diagonal agitated brushstrokes
  ctx.globalAlpha = 0.5;
  for (let i = 0; i < 20; i++) {
    const x1 = (i / 20) * W * 1.2 - W * 0.1 + Math.sin(t * 0.01 + i) * 30;
    const y1 = -20 + Math.cos(t * 0.008 + i * 0.7) * 30;
    const len = 150 + Math.sin(t * 0.02 + i) * 80;
    const angle = -0.5 + Math.sin(t * 0.005 + i * 0.3) * 0.4;
    
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(
      x1 + Math.cos(angle) * len,
      y1 + Math.sin(angle) * len + 100
    );
    ctx.strokeStyle = colors[(i + 2) % colors.length];
    ctx.lineWidth = 3 + Math.abs(Math.sin(t * 0.03 + i)) * 8;
    ctx.stroke();
  }
}

function drawSun(t) {
  const sx = W * 0.75 + Math.sin(t * 0.006) * 40;
  const sy = H * 0.18 + Math.cos(t * 0.009) * 20;
  const r = 45 + Math.sin(t * 0.01) * 10;
  
  // Glowing halo
  for (let i = 4; i > 0; i--) {
    const grd = ctx.createRadialGradient(sx, sy, 0, sx, sy, r * (1 + i * 0.4));
    grd.addColorStop(0, 'rgba(240, 180, 30, 0.4)');
    grd.addColorStop(1, 'rgba(200, 50, 10, 0)');
    ctx.beginPath();
    ctx.arc(sx, sy, r * (1 + i * 0.4), 0, Math.PI * 2);
    ctx.fillStyle = grd;
    ctx.globalAlpha = 0.3;
    ctx.fill();
  }
  
  // Sun body
  ctx.beginPath();
  const numRays = 12;
  for (let i = 0; i <= numRays; i++) {
    const angle = (i / numRays) * Math.PI * 2 + t * 0.005;
    const rad = (i % 2 === 0 ? r : r * 0.7) + Math.sin(t * 0.04 + i) * 8;
    const px = sx + Math.cos(angle) * rad;
    const py = sy + Math.sin(angle) * rad;
    i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
  }
  ctx.closePath();
  ctx.fillStyle = colors[3];
  ctx.globalAlpha = 0.9;
  ctx.fill();
  ctx.strokeStyle = colors[0];
  ctx.lineWidth = 3;
  ctx.stroke();
}

function render() {
  t++;
  ctx.clearRect(0, 0, W, H);
  ctx.globalAlpha = 1;
  
  // Dark base
  ctx.fillStyle = '#0a0a14';
  ctx.fillRect(0, 0, W, H);
  
  drawSky(t);
  ctx.globalAlpha = 1;
  drawLines(t);
  drawSun(t);
  drawGround(t);
  
  // Figures
  ctx.globalAlpha = 0.85;
  drawFigure(W * 0.28, H * 0.72, 1.1, t * 0.02);
  drawFigure(W * 0.52, H * 0.78, 0.85, t * 0.018 + 1.2);
  drawFigure(W * 0.7, H * 0.7, 1.0, t * 0.022 + 2.5);
  
  // Vignette
  ctx.globalAlpha = 1;
  const vig = ctx.createRadialGradient(W/2, H/2, H*0.3, W/2, H/2, H*0.85);
  vig.addColorStop(0, 'rgba(0,0,0,0)');
  vig.addColorStop(1, 'rgba(0,0,0,0.55)');
  ctx.fillStyle = vig;
  ctx.fillRect(0, 0, W, H);
  
  requestAnimationFrame(render);
}

render();
</script>
</body>
</html>
